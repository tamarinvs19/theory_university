\lecture{3}{19 nov}{\dag}

\section{Теорема Кука-Левина}
$ \tThreeSAT = \{(F, A) \mid F \text{ --- в 3-КНФ}, F(A) = 1\}$.
\begin{ex}
    \[
		\left( (\neg x \vee \neg y \vee \neg z) \wedge (y \vee \neg z) \wedge (x), [x = 0, y= 1,  z=1] \right) \in  \tThreeSAT 
    .\] 
\end{ex}
\begin{thm}[Кук-Левин]
	$ \tThreeSAT$ --- \NP-полная задача. 
\end{thm}
\begin{proof}
	Мы уже доказали полноту задач выполнимости булевых схем, поэтому будем сводить к ней.

	Пусть у нас есть некоторая схема. Для каждого гейта заведем по переменной, которая обозначает результат операции в этом гейте. Входы тоже остаются гейтами в схеме.

	Запишем для гейтов клозы длины 3, которые выражают результат в зависимости от аргументов.

	Например, для входов $ x$, $ y$ и операции $ \oplus = g(x, y)$, 
	\[
	\begin{aligned}
		&(x \vee y \vee \neg g) \\
		&(\neg x \vee \neg y \vee \neg g) \\
		&(x \vee \neg y\vee g) \\
		&(\neg x \vee y \vee g)
	\end{aligned}
	\]

	Еще для последнего гейта $ g$ (выходного) запишем клоз $ (g)$.

	Значение в полученной схеме будет соответствовать результату конъюнкции всех переменных и наоборот: по формуле можем построить булеву схему и входные переменные выполняют ее.
\end{proof}
\begin{thm}
	Пусть $ R \in \tNP$, и соответствующий язык полон  $ L(R) $ --- \NP-полон. Тогда  $ R$ сводится по Тьюрингу к $ L(R)$.
\end{thm}
\begin{proof}
	Во-первых, задача поиска из $ \NP$ сводится к $ \tSAT$. При этом $ \SAT$ сводится к $ L(R)$.
	
	Осталось свести $ \tSAT \to \SAT$. Пусть нам дали выполняющий набор для $ F$. Подставим первую переменную $ x_1$  как $0$ и как $ 1$ в $ F$ (это тоже формулы) и спросим у оракула $ \SAT$ про $ F[x_1=0] \in \SAT$  и $ F[x_1=1] \in \SAT$.

	Так как $ F$ выполнима, хотя бы одна из полученных схем выполнима. Выберем ее и продолжим подставлять в нее. Так мы дойдем до конечной истиной формулы. Следовательно, последовательность подставляемых значений $ x_i$ и будет выполняющим набором.
\end{proof}
\subsection{Оптимальный алгоритм для $\tNP$-задачи}
Пусть мы хотим решить задачу, заданную отношениям $ R$, с входом $ x$.
Давайте переберем все машины (не только полиномиальные) и, если какая-то машина выдала результат $ y $ проверим его $ R(x, y)$ за полином. Если ответ подошел, то просто заканчиваем работу, иначе продолжаем ждать других результатов.

Если машины были бы запущены параллельно, то мы бы нашли ответ за время самой быстрой машины на данном входе.

А мы будем делать шаги <<змейкой>>: выделим для $ l$-ой машины $ 2^{-l}$ времени. 

На очередном этапе $ 2^{l}(1 + 2k)$ будем моделировать $ k$-ый шаг машины $ M$. 

Посчитаем замедление алгоритма. Мы хотим выдать ответ не сильно позже, чем самая быстрая машина. Но заметим, что такая машина одна, поэтому $ l$ это константа, следовательно, множитель $ 2^{l}$ тоже константа.

Как моделировать эти машины? Если было бы быстрое обращение к каждому элементу памяти, то $ t(x) \le \const_i \cdot t_i + p(\lvert x \rvert )$ (последнее на проверку), в случае с ДМТ получаем  $ t(x) \le \const_{i}\cdot p(t_i(x))$.

\begin{note}
	Если $ \P = \NP$, то построенный алгоритм может решить $\SAT$ за полиномиальное от времени работы самой быстрой машины  $ p(t_i(x))$, но и оно полиномиально в случае $ \P = \NP$.
\end{note}

\begin{thm}
	Если $ \P \ne \NP$, то существует язык $ L \in \NP \setminus \P$, \textbf{не} являющийся $ \NP$-полным.
\end{thm}
\begin{proof}
	Найдем задачу, которая и не в $ \P$ и не является  $ \NP$-полной. 

	Занумеруем все полиномиальные ДМТ с полиномиальными будильниками (настроенными на по полиномиальное время):
	\[
	M_1, M_2, \ldots 
	.\] 
	Аналогично пронумеруем полиномиальные сведедения с будильниками, то есть ожидаем какой-то ответ на выходе:
	\[
	R_1, R_2, \ldots 
	.\] 

	Построим следующий язык $ \K = \{x \mid x \in \SAT \wedge f(\lvert x \rvert ) = 0 \pmod 2 \}$, где $ f(n)$ ведет себя следующим образом:
	\begin{enumerate}
		\item за $ n$ шагов вычисляем $ f(0), f(1), \ldots f(i) \eqqcolon k$ ($ k$ --- последнее значение, которое мы успели вычислить).
		\item тоже за $ n$ шагов:
			\begin{enumerate}
				\item если $ k = 0 \pmod 2$, то проверим, что $\exists z\colon  M_{\frac{k}{2}}(z) \ne \K(z)$, и в случае успеха вернем $ k+1$, иначе (или истратили $ n$ шагов) $ k$;
				\item если $ k = 1 \pmod 2$, проверим, что очередное $ R_{\frac{k-1}{2}}$ правильно сводит $ \SAT$ к $ R$: если  $ \exists z\colon \K(R_{\frac{k-1}{2}}(z)) \ne \SAT(z)$, возвращаем $ k+1$, в любом другом случае --- $ k$.
			\end{enumerate} 
			Здесь первый пункт проверяет $ \K \in \P$, а второй --- $ \SAT \to \K$, то есть $ \K \in \NP\text{-трудная}$.

			Для какого-то огромного $ n$ найдутся контр-примеры и мы получим $ k+1$. 
		\item $ f(0) = 0$
	\end{enumerate} 
	
	Заметим, что $ \K \in \NP$, так как выполняющий набор можно проверить принадлежность $ \SAT$ за полином и подставить в $ f$, которая тоже работает полином ($ 2n$ шагов).

	\begin{itemize}
		\item
	Пусть $ \K \in \P$, тогда  есть полиномиальная машина $ M$, которая принимает этот язык. Поэтому в пункте (a) мы дальше этой машины не пройдем, так как  контр-примера там нет. То есть с некоторого момента $ f(n) = 0 \pmod 2$, по определению с некоторого места   $ \K = \SAT$, кроме конечного числа случаев, их можно разобрать отдельно. 
	Тогда $ \K \in \NPcomp $ и $ \K \in \P$, поэтому $ \P = \NP$.
\item Если $ \K \in \NPcomp$, то с некоторого момента мы не пройдем пункт (b), так как у нас действительно будет сводимость к $ \K$.
	С некоторого места  $ f(n) = 1 \pmod 2$, а тогда  $ \lvert \K \rvert < \infty$. Следовательно, $ \K \in \P$. Опять противоречие. 
	\end{itemize}
\end{proof}

\section{Полиномиальная иерархия}
\begin{name}
Пусть есть два класса языков $ \Cclass, \Dclass$. Можно построить класс $ \Cclass ^{\Dclass}$, который состоит из  языков вида $ C^{D} $, где $ D \in \Dclass$ и $ C$ --- машина для языка из $ \Cclass$.
\end{name}
\begin{defn}[Класс дополнений]
    \[
    \coC = \{L \mid \overline{L} \in \Cclass\}
    .\] 
\end{defn}
\begin{ex}
	$ \SAT \in \NP$, дополнение к $ \SAT$, то есть $ \{\text{всюду ложные формул}\} \in \coNP$.
\end{ex}

\subsection{Полиномиальная иерархия}
Самый нижний класс иерархии --- $ \P$. Остальные классы строятся также из  $ \NP$ и $ \coNP$.
\begin{figure}[b!]
    \centering
    \incfig{hierarchy}
    \caption{Полиномиальная иерархия}
    \label{fig:hierarchy}
\end{figure}
\[
\begin{aligned}
	&\SIGMA ^{0}\P = \PI ^{0}\P = \DELTA ^{0} \P = \P \\
	& \SIGMA ^{i+1} \P = \NP^{\PI^{i}\P} \\
	& \PI^{i+1}\P = \coNP^{\SIGMA ^{i}\P}\\
	& \DELTA ^{i+1}\P = \P^{\SIGMA ^{i}\P} \\
	& \PH = \bigcup_{i \ge 0} \SIGMA ^{i} \P
\end{aligned}
\]

\begin{lm}
    $ \NP^{\PI^{i}\P} = \NP^{\SIGMA^{i}\P}$
\end{lm}
\begin{proof}
    Пусть есть машина $ M$ с оракулом $ A$. Рассмотрим оракул $ \overline{A}$ и построим машину $ M'$, чтобы $ M'^{\overline{A}}$ вела себя аналогично $ M^{A}$. Для этого просто $ M'$ будет переворачивать любой ответ, полученный от оракула, все остальные действия повторяем за $ M$.

	Из этого следует, что можно поменять $ \PI^{i}\P$ на $ \overline{\PI^{i}\P} = \coNP^{\PI^{i}\P} = \SIGMA^{i}\P$.
\end{proof}

\begin{thm}
    $ L \in \SIGMA^{k}\P$, согда \footnote{тогда и только тогда, когда} существует полиномиально ограниченное отношение $ R \in \PI^{k-1}\P$ такое, что для всех $ x$ :
	\[
		x \in L \Longleftrightarrow \exists y \colon R(x, y)
	.\] 
\end{thm}
\begin{proof}
   \begin{description}
       \item \boxed{ 1 \Longrightarrow 2} 
		   Докажем по индукции. 
		   \begin{itemize}
			   \item База: по определению $ \SIGMA^{1}\P = \NP$.
			   \item Переход: $ k-1 \to  k$. Пусть $ L = L(M^{O})$, где $ M$ --- полиномиальная НМТ, $ O \in \SIGMA^{k-1}\P$.

				   По предположению индукции для $ O$ существует полиномиально ограниченное $ S \in \PI^{k-2}\P$ такое, что $ \forall q\colon q \in O \Longleftrightarrow \exists w \colon S(q, w)$.

				   Сконструируем из этого $ R$:
				   \begin{itemize}
					   \item $ R(x, y) = 1$, если $ y$ --- принимающая ветвь вычисления $ M^{O}$, при этом положительные ответы оракула должны быть снабжены сертификатами  $ w\colon  S(q, w) = 1$.

						   То есть все переходы,  основанные на ответе оракула <<да>>, должны также содержать <<доказательство>>.

						   Проверим, что это отношение из $ \PI^{k-1}\P$, и, что оно задает язык $ L$.
					   \item $ R \in \PI^{k-1}\P$: детерминировано проверяем корректность $ y$, а далее проверяем, что ответы оракула были верными. Для ответов <<нет>> нужно проверить, что $ O$ для него равно нулю ($ \PI^{k-1}\P$ вычисление), а для ответов <<да>>  --- что  $ S$ равно  $ 1$, то есть проверить сертификат ($ \PI^{k-2}\P$ вычисление).

						   Нужно, чтобы все $ \PI^{k-1}\P$ и $ \PI^{k-2}\P$ (это частный случай $ k-1$) вычисления вернули <<да>>. Для этого построим схему: присоединим к большой конъюнкции все вычисления, чтобы ответ был положительным, нужно, чтобы все ветки $ \PI^{k-1}\P$ (то есть $ \coNP$) вернули одно и то же, при этом мы остаемся в $ \PI^{k}\P$.
				   \end{itemize}
				   Для машины $ M$ существует принимающее вычисление и оно может быть дано в качестве $ y$.

				   Наоборот, если у нас есть корректное вычисление машины $ M$, то оно и будет принадлежать $ L$.
		   \end{itemize}
       \item \boxed{ 2 \Longrightarrow 1}
		   Пусть у нас есть отношение $ R$.
		   Возьмем машину с оракулом $ R$.
		   Она будет недетерминировано 
		   выбирать $ y$ и проверять, то есть спрашивать у оракула, $ R(x, y)$.
   \end{description}  
\end{proof}
\begin{thm}
	$ L \in \PI^{k}\P$, согда существует полиномиально ограниченное отношение $ R \in \SIGMA^{k-1}\P$ такое, что для всех $ x$ :
	\[
		x \in L \Longleftrightarrow \forall  y \colon R(x, y)
	.\] 
\end{thm}
\begin{cor}
    $ L \in \SIGMA^{k}\P$, согда существует полиномиально ограниченное отношение $ R \in \P$ такое, что для всех $ x$:
	\[
		x \in L \Longleftrightarrow \exists y_1 \forall y_2 \exists y_3 \ldots R(x, y_1, y_2, \ldots y_k)
	.\] 
\end{cor}
\begin{cor}
    $ L \in \PI^{k}\P$, согда существует полиномиально ограниченное отношение $ R \in \P$ такое, что для всех $ x$:
	\[
		x \in L \Longleftrightarrow \forall y_1 \exists  y_2 \forall  y_3 \ldots R(x, y_1, y_2, \ldots y_k)
	.\] 
\end{cor}

