# Agile разработка. Agile манифест. Раздробленное видение <a name="1"></a>
* Это набор методов, который охватывает все области программирования (управление проектом, дизайн, архитектура, разработка)
* Все методы - четкие и оптимизированные процедуры
* Это мировоззрение

### Agile манифест
* Люди и взаимодействие важнее процессов и инструментов (ежедневные митинги, ретроспективы, user-story)
* Работающий программный продукт важнее исчерпывающей документации (разработка через тестирование)
* Сотрудничество с заказчиком важнее согласования условий контракта
* Готовность к изменениям важнее следования первоначальному плану (доска задач)

### Раздробленное видение
Чем больше люди сосредоточены на своих личных целях, а не на целях команды, тем меньше шансов, что они будут иметь реальную ценность для компании.
* Agile-митинги

# Agile-принципы <a name="2"></a>

1. Наш наивысший приоритет - это удовлетворение заказчика при помощи частых и непрерывных поставок ценного для него ПО. 
2. Мы принимаем изменения в требованиях даже на поздних этапах реализации для повышения конкурентоспособности продукта.
3. Мы стремимся поставлять полностью рабочее ПО каждые несколько недель. Чем чаще, тем лучше
4. Наиболее эффективный и действенный способ передачи информации - встреча членов команды разработки.
5. Представители бизнеса и команда разработчиков должны работать над проектом вместе.
6. Проекты строятся вокруг мотивированных людей.
7. Рабочее ПО - главная мера прогресса проекта.
8. Гибкие процессы способствуют непрерывному развитию. 
9. Постоянное внимание к техническому совершенству и качественной архитектуре способствует гибкости.
10. Простота - это искусство не делать лишений работы. KISS (Keep it simple, stupid)
11. Лучшая архитектура, требования и дизайн создаются в самоорганизующихся командах.
12. Команда постоянно ищет способы стать более эффективной путем настройки и коррекции своих действий.

# SCRUM. Схема scrum-проекта. Роли. Митинги <a name="3"></a>

### Роли
* Владелец продукта: определяет приоритеты функций, помогает команде понять ценность ПО, берет на себя выполнение обязательств, пишет user-story, создает планы релизов, проводит совместную ретроспективу
* Scrum-мастер: поддерживает правильное направление работы над проектом, помогает создать план, отслеживает прогресс, разбивает на итерации
* Член команды: выступает в роли владельца проекта, искренне считает, что их личный успех зависит от успешности проекта 

### Scrum-ценности
* Каждый человек ответственен за цели проекта
* Члены команды уважают друг друга
* Все сосредоточены на работе
* Команды ценят открытость
* Члены команды имеют мужество отстаивать проект

### Митинги
* обратная связь и цикл "обзор-контроль-адаптация" (что я сделал, что планирую, какие препятствия?)
* принятие решений в последний ответственный момент

# Спринты, планирование и ретроспективы. Фокус-фактор. Диаграммы сгорания работ <a name="4"></a>
* Инкрементальный процесс: сборка по частям
* Итеративный процесс: scrum-спринты

### Планирование
* user story -> story point
* задачи
* доска задач

Итог: цель, список участников + занятость, sprint backlog (список вошедших историй), дата демо

### Фокус-фактор
`FF = Actual Velocity / Available Man Days`

### Диаграммы сгорания работ
Способ показать и оценить прогресс

# XP. Практики программирования, интеграции, планирования. Командные практики <a name="5"></a>
### Практики программирования
* Разработка через тестирование
* Парное программирование
### Практики интеграции
* Десятиминутная сборка, авто-тесты, отчеты
* Непрерывная интеграция, система контроля версий
### Практики планирования
* Недельный цикл
* Квартальный цикл
* Временной запас
### Командные практики
* Коллокация
* Информативное рабочее пространство
* Излучатели информации
### Ценности
* Коммуникация
* Простота
* Обратная связь
* Мужество
* Уважение

# LEAN <a name="6"></a>
Бережливое мышление

### Ценности
* Ликвидируйте потери
* Усильте обучение, используйте обратную связь, чтобы улучшить работу
* Принимайте решения как можно позже
* Доставляйте ценность как можно раньше
* Раскрепостите вашу команду, объедините энергичных людей
* Добейтесь целостности, ПО должно работать сообразно ожиданиям
* Следите за общей картиной

# KANBAN. WIP <a name="7"></a>
KANBAN - способ улучшения процессов.

* Начните с того, что вы делаете сейчас, уважайте имеющиеся роли, обязанности и должностные конструкции
* Договоритесь об эволюционном развитии
* Поощряйте лидерство на всех уровнях

### Практики
* Визуализация
* Ограничение числа задач в работе (WIP)
* Управление потоком
* Сделайте правила явными
* Введите петли обратной связи
* Развивайтесь совместно и экспериментируйте

Канбан доски содержат только истории, могут устанавливаться лимиты, могут отличаться в разных командах

### WIP
Установление ограничения на количество рабочих элементов, которые могут находится на разных стадиях реализации проекта

# MSF. Модель процесса. <a name="8"></a>
Microsoft Solutions Framework

### Принципы
* Способствуйте открытому общению
* Работайте над общим видением
* Расширяйте полномочия членов команды
* Разделяйте ответственность
* Сотрудничайте с клиентом и сосредоточьтесь на предоставлении бизнес-ценности
* Будьте готовы к переменам и оставайтесь гибкими
* Инвестируйте в качество
* Учитесь на опыте

Модель команды - горизонтальная иерархия

Модель процесса - водопад + спиральная модель: выработка концепции -> концепция утверждена -> планирование -> планы утверждены -> разработка -> разработка завершена -> стабилизация -> версия готова -> внедрение -> внедрение завершено -> 

Управление проектом:
* комплексное планирование
* управление бюджетом, расходами и ресурсами
* подготовка графиков и контроль за их соблюдением
* ведение административной документации
 
Управление рисками: база рисков, определение, сообщение о, анализ и приоритет, план и график, отслеживание и отчет, контроль, знание

Управление готовностью: профессиональный рост, подготовка специалистов; от готовности зависит способность сотрудника выполнять ту или иную роль
- определение
- оценка
- изменение
- подведение итогов

# Программный процесс. Плановые и гибкие процессы. Виды деятельности <a name="9"></a>
Все программные процессы включают:
* спецификацию
* дизайн и внедрение
* валидацию
* эволюцию

__Модель программного процесса__ - _это абстрактное представление процесса. Представляет собой описание процесса с определенной точки зрения._

Описание ПП может включать:
- действия в процессах
- упорядочивание действий
- продукты (результат)
- роли (обязанности участников)
- пред-, постусловия

### Плановые и гибкие процессы
* в соответствии планом, прогресс относительно плана
* инкрементальное планирование, план может меняться

### Базис процессов разработки ПО:
* Деятельность
  * Действие
    * Задача

### Виды деятельности
* Подготовка (цели, сбор и анализ требований)
* Планирование (порядок работы, риск, ресурсы)
* Моделирование
* Конструирование
* Развертывание (поставка, внедрение, сопровождение)

### Виды защитной деятельности
* Отслеживание и контроль ПП
* Управление риском
* Обеспечение качества ПО
* Технические проверки
* Измерение
* Управление конфигурацией ПО
* Управление повторной используемостью
* Подготовка и производство рабочего продукта

# Модель и методология разработки ПО. Этапы жизненного цикла ПО <a name="10"></a>
Модель разработки ПО описывает, какие стадии жизненного цикла оно проходит и что происходит на каждой из них.

Методология - набор методов по управлению разработкой (правила, техники, принципы)

### Этапы жизненного цикла ПО
Жизненный цикл - этапы, через которые проходит ПО с начала создания до конца разработки
* Подготовка
* Проектирование
* Создание
  - Дизайн
  - Кодирование
  - Тестирование
  - Документирование
* Поддержка
 - Внедрение
 - Сопровождение

# Водопадная модель <a name="11"></a>
Waterfall Model / Каскадная модель
### Сопровождение ПО
* исправление ошибок 17%
* адаптация 18%
* усовершенствование по требованию заказчика 65%
### Достоинства
* разработку просто контролировать
* стоимость определяется на начальном этапе
* тестировщики могут опираться на техническую документацию
### Недостатки
* негибкое разделение на этапы -> сложно реагировать на меняющиеся требования
* тестирование на последних стадиях
* заказчик может дать обратную связь только на готовый продукт
* много документации, задержка, изменения при исправлении

# V-образная модель <a name="12"></a>
Параллельно проектированию происходит соответствующее тестирование

# Эволюционная модель <a name="13"></a>
Общая схема: получаем описание, создаем новые версии последовательно

* __Метод пробных разработок__ - заказчик не готов сразу определить полный состав требований
* __Метод прототипирования__ - заказчик готов определить полный набор требований, но разработчик не готов сразу предложить решения

### Достоинства
* сокращение сроков разработки
* возможность уточнять спецификацию компонентов
### Недостатки
* плохая документация
* плохая структура

# Спиральная модель <a name="14"></a>
Постепенная разработка с расширением функциональных возможностей.
### Достоинства
* объем работы при разработке одной версии меньше
* опыт разработки старших версий будет учтен
* в случае неудачи меньше материальные потери
* разработанные версии могут быть внедрены, реальная польза для заказчика
### Недостатки
* риск застрять на начальном этапе
* трудности контроля и управлением времени разработки
* повышенные требования к заказчику - нужно проверять версии

# Инкрементальная модель <a name="15"></a>
Последовательная реализация новой функциональности в новых версиях и развертывание каждой новой версии у заказчика.

### Достоинства
* на начальном этапе можно вкладывать меньше денег
* быстрый фидбэк от пользователей
* ошибка дешевле, чем в водопаде / V-образной модели

### Недостатки
* менеджер должен контролировать задачи разработчиков, чтобы развивалась требуемая функциональность
* могут быть проблемы с интерфейсов между командами

# Итеративная модель <a name="16"></a>
Модель, при которой заказчик не обязан понимать, какой продукт он хочет в итоге, может не прописывать подробное ТЗ. Один релиз.

### Достоинства
* быстрый выпуск минимального продукта -> быстрый фидбэк, можно фокусироваться на наиболее важных функциях и улучшать их по требованию
* постоянное тестирования пользователями

### Недостатки
* возможно потребуются сильные изменение в DB и сервере (масштабирование, нагрузка)
* нет фиксированного бюджета и сроков

# Ролевая модель команды. Менеджер проекта. Проектировщик. Разработчик. Тестировщик. <a name="17"></a>
### Менеджер проекта
* подбор и управление кадрами
* подготовка и исполнене плана продукта
* руководство командой
* обеспечение связи 
* обеспечение готовности продукта

### Проектировщик
* анализ требований
* разработка архитектуры и основных интерфейсов
* участие в планировании
* контроль выполнения
* участие в подборе кадров

### Разработчик
* создание кода
* контроль архитектурных и технических спецификаций
* подбор и конроль использования инструментов, стандартов
* диагностика и разрешение проблем
* контроль за работой тестировщиков
* мониторинг состояния

### Тестировщик
* составление плана тестирования
* контроль выполнения плана тестирования
* разработка тестов, автотестов
* выбор стандартов, метрик и инструментов

# Технический писатель. Технолог <a name="18"></a>
### Техписатель
* разработка плана документирования
* выбор и разработка стандартов и шаблонов подготовки документов
* выбор средств автоматизации документирования
* разработка документации
* организация тестирования документации
* участи в тестировании продукта

### Технолог
* поддрежка модели жизненного цикла
* создание и сопровождение среды сборки, процедуры установки версий
* управление исходниками

# Процессная деятельность. Спецификация, разработка, проверка и эволюция <a name="19"></a>
### Спецификация
* процесс определения того, какие услуги требуются, а также ограничений для работы и развития системы
* процесс разработки требований (сбор, детальное определение, проверка)

### Проверка
* верификация и валидация
* монитроринг
* системное тестирования: проверка на примерах

### Эволюция
* изменение требований из-за меняющихся обстоятельств

# Работа с меняющимися требованиями. Прототипирование. Инкрементальная доставка <a name="20"></a>
Преимущества прототипирования:
* повышение удобства системы
* более точное соответствие потребностям
* повышение качества дизайна
* повышение сопровождаемости
* снижение усилий при разработке

# Совершенствование процессов. Цикл улучшения процесса. <a name="21"></a>
* подход к зрелости процессов: улучшение уравления процессами и проектами и внедрении предовой практики разработки ПО; уровень зрелости - степень внедрения практик в процессы
* гибкий подход: итеративная разработка, сокращение накладных ресурсов; быстрое предоставление функциональности и реагирование на изменение требований 

Цикл: измерение -> анализ -> изменения

Измерение:
- количественные данные: время, ресурсы, количество появлений определенного события

# Capability Maturity Model (CMM) <a name="22"></a>
Уровни зрелости возможностей:
* Начальный: качество продукта определяется индивидуальными способностями разработчиков
* Повторяемый: есть записи о трудозатратах и планах, функциональность описана в письменной форме
* Установленный: имеют определенный, документированный процесс работы, не зависящий от отдельных личностей
* Управляемый: могут предсказать сроки и стоимость, есть база знаний
* Оптимизированный: постоянно действующая процедура поиска и освоения новых и улучшенных методов и инструментов

# Типы требований. Функциональные и нефункциональные требования <a name="23"></a>
* пользовательские требования: заявления на естественном языке + диаграммы сервисов, ограничения эксплуатации; для клиентов
* системные требования: документ с подробным описанием функций и ограничений, может быть частью контракта

### Функциональные требования
* описывают функциональные возможности системы
* зависят от типа ПО, пользователей, типа системы
* требования пользователей -> что система должна делать
* системные требования -> подробное описание услуги

### Нефункциональные требования
* свойства и ограничения системы: надежность, время отклика, требования к хранению... 
* могут быть к процессу, требующие IDE, язык или метод разработки
* могут быть более важными

### Полнота и последовательность требований
* полнота - должны включать описания всех необходимых объектов
* последовательность - нет противоречий

# Сбор и анализ требований. Интервью. Этнография. Истории и сценарии <a name="24"></a>
### Обнаружение требований
- сбор информации о требуемых и существующих системах, извлечение пользовательских и системных требований
- взаимодействие с заинтересованными сторонами системы
### Интервью / собеседование
* Типы:
  - закрытое по составленному списку вопросов
  - открытое с обсуждением различных вопросов с заинтересованными сторонами 
* Проблемы:
  - разный язык разных сфер
  - не подходит для понимания требований предметной области
### Этнография
* социолог тратит много времени на наблюдение и анализ того, как на самом деле работают люди
* не нужно объяснять или формулировать свою работу
* можно отметить важные социальные и организационные факторы
* работа обычно сложнее, чем предполагают простые модели
### Истории и сценарии
Примеры из реальной жизни, как можно использовать систему
* Сценарий - структурированная форма user story
 - исходная ситуация
 - нормальный поток событий
 - что может пойти не так
 - другая параллельная деятельность
 - состояние завершения

# Технические требования. Структурированные и табличные спецификации. Use cases <a name="25"></a>
* требования пользователей - понятны конечным пользователям и клиентам без техобразования
* системные требования - более подробная информация
### Способы написания спецификации системных требований
* естественный язык
* структурированный естественный язык
* язык описания дизайна
* графические обозначения
* математические характеристики

Структурированная спецификация - свобода составителя ограничена, требования написаны стандартным способом (список полей)
Табличная спецификация - для дополнения естественного языка

### Use cases
- варианты использования
- участники и все взаимодействия
- графическая модель высокого уровня дополнена табличным описанием
- диаграммы последовательности UML для добавления деталей

# Проверка/верификация требований. Методы проверки требований <a name="26"></a>
### Проверка
* достоверность
* последовательность
* полнота
* реалистичность
* проверяемость

### Методы проверки
* обзоры требований (ручной анализ)
* прототипирование
* генерация тест-кейсов (требования у проверке тестируемости)

### Верификация
* проверяемость
* понятность
* прослеживаемость
* адаптивность

# Управление требованиями и изменениями требований. <a name="27"></a>
__Управление требованиями__ - _процесс управления изменяющимися требованиями в процессе разработки требований и разработки системы_

* Идентификация требований
* Процесс управления изменениями: действия которые оценивают влияние и стоимость изменений
* Политики прслеживаемости: отношения между каждым требованием, между требованиями и проектом
* Инструменты для планирования

Изменение требований:
- анализ проблемы и изменение спецификации
- анализ изменений и вычисление стоимости изменений
- реализация изменения

# UML. Диаграммы классов. Атрибуты, ассоциации, кратность, зависимость. <a name="28"></a>
# Агрегация и композиция. Примеры. <a name="29"></a>
# Множественная классификация и множественное наследование. <a name="30"></a>
# UML. Диаграммы последовательности. Диаграммы прецедентов. <a name="31"></a>
# UML. Диаграммы состояний. Диаграммы деятельности <a name="32"></a>
# Модели взаимодействия. Примеры UML <a name="33"></a>
# Структурные модели. Примеры UML <a name="34"></a>
# Модели поведения. Примеры UML <a name="35"></a>
# Модельно-ориентированная инженерия <a name="36"></a>

# Дизайн и архитектура ПО. Две ценности программных систем. Достоинства хорошей архитектуры <a name="36"></a>
Архитектура - используется в контексте общих рассуждений.

Дизайн - подразумевает организацию и решения на более низком уровне.

Две ценности:
* Поведение (функциональность): срочное, но не всегда важное
* Структура (архитектура): важное, но не всегда срочное

Если программа работает правильно, но не допускает возможности изменения, когда изменятся требования, она перестанет работать правильно.

Если программа работает неправильно, но легко поддается изменению, ее можно заставить работать правильно.

__Архитектура программного проекта__ - _высокоуровневое представление структуры системы, спецификация ее компонентов и логики взаимодействия_

Хорошая архитектура должна обеспечивать:
* разнообразие вариантов использования и эффективную работу
* простота сопровождения
* простота разработки
* простота развертывания

# Многоуровневая архитектура <a name="37"></a>
Система - набор уровней (представление моделей, бизнес логика, хранение данных, базы данных)
- Используется при строительстве поверх существующих
- когда работа распределена между специализированными командами
- когда требуется многоуровневая безопасность
Преимущества:
- можно заменять слой отдельно, поддерживая интерфейс
- на каждом уровне можно предусматривать дополнительные средства (например, аутентификация)
Недостатки:
- четкое разделение сложно обеспечить
- производительность из-за нескольких уровней

# Модель - представление – контроллер. MVC, MVP, MVVM <a name="38"></a>
* Model - управляет системными данными
* View - определяет и управляет интерфейсом пользователя
* Controller - управляет взаимодействием с пользователем и передает его в представление и модель

```
С <-> V
|     ^
|     |
-> M <-
```

Цели:
- Добиться слабой связности между моделью и представлением, тогда можно сделать несколько представлений или легко изменить текущее
- Инкапсулировать бизнес-логику, чтобы разрабатывать и тестировать отдельно
- Сделать представление (view) максимально тонким, чтобы уменьшить тестирование

Преимущества:
- позволяет данным изменяться независимо от их представления и наоборот
- поддерживает одинаковое представление  различных данных

Недостатки: могут появиться дополнительные усложнения кода

MVC: контроллер - связь между пользователем и системой, отправляет данные между view и model; представление отвечает за получение данных из модели, предоставление их пользователю; модель предоставляет данные и методы работы с ними, ни от кого не зависит 

MVVM: модель - работа с данными; представление - графический интерфейс, подписчик на события изменения свойств или команд ViewModel, вызывает команды ViewModel при действиях пользователя; ViewModel - абстракция представления и обертка данных модели.

MVP: модели - данные; view - отображение данных из модели, обращается к presenter за обновлениями, перенаправляет события от пользователя в presenter; presenter - взаимодействие между model и view, содержит всю логику представления данных.


# Шаблон репозитория <a name="39"></a>
Все данные управляются в центральном репозитории, доступном для всех компонентов.

Использование:
- есть система, где генерирутся большие объемы информации, которую нужно хранить долго
- когда включение данных в репозиорий запускает действие

Преимущества:
- компоненты независимые, но имеют доступ к репозиторию
- изменения, внесенные одним компонентом могут быть распространены на все

Недостатки:
- репозиторий - единственная точка отказа системы
- возможна неэффективность в организации общения через репозиторий

# Архитектура каналов и фильтров <a name="40"></a>
Каждый компонент обработки (фильтр) - дискретный, выполняет один тип преобразования данных.

Использование: для поэтапной обработки данных

Преимущества:
- поддерживает повторное использование преобразований
- стиль соответствует структуре многих бизнес-проектов
- простое расширение функциональности
- может быть реализована как последовательная, так и параллельная

Недостатки:
- формат должен быть согласован, может увеличивать накладные расходы на проверку и преобразование данных

# Архитектура, управляемая событиями <a name="41"></a>
* распределенная и асинхронная
* высокая производительность, легкость развертывания, широкие возможности масштабирования

# Микроядерная архитектура <a name="42"></a>
Состоит из двух компонентов: основной системы (ядра) и плагинов.
Ядро - минимум бизнес-логики, управляет загрузкой, выгрузкой, запуском плагинов.
Плагины  не связаны между собой.

# Микросервисная архитектура <a name="43"></a>
Разделение функциональности на отдельные сервисы.

Преимущества:
-  высокая масштабируемость
- легкость распределения задач

Недостатки:
- необходимость передачи большого объема данных
- необходимость автоматизации развертывания и тестирования

# Модульная архитектура. Информационная закрытость <a name="44"></a>
- снижение сложности
- иерархическая декомпозиция
- обеспечиваем гибкость системы, масштабирование, устойчивость

### Информационная закрытость
- все модули независимы и обмениваются только той информацией, которая необходима для работы
- доступ к операциям и структурам данных модуля ограничен 
- позволяет обеспечить разработку модулей независимо
- позволяет обеспечить легкую модификацию

Идеальный модуль - черный ящик.

# Связность модуля. Типы связности <a name="45"></a>
### Модульная декомпозиция
- иерархическая декомпозиция (бизнес-логика, UI, DB, связь с оборудованием или ОС
- функциональная декомпозиция (один модуль - одна подзадача и один набор необходимых данных)

### High Cohesion + Low Coupling
- максимальная внутренняя связность (функциональная целостность, завершенность)
- минимальная внешняя связность (один вход и выход, логическая независимость, слабые связи с другими)

Внутренняя связность - мера зависимости частей модуля друг от друга
1. по совпадению 
1. логическая 
1. временнАя (нужны в один момент времени)
1. процедурная (независимые упорядоченные действия)
1. коммуникативная (используют одни данные или формируют общую структуру данных)
1. последовательная (конвейер для обработки данных)
1. функциональная (выполнение ровно одной проблемной задачи)

# Внешняя связанность / Coupling. Типы связности <a name="46"></a>
1. связность по данным
1. связность по образцу
1. связность по управлению
1. общая связность
1. связность по содержанию

# Парадигмы программирования
# ООП. Основные принципы

# SOLID. Принцип единственной ответственности
Single responsibility principle: для каждого класса определено единственное назначение. Все ресурсы, необходимые для его осуществления должны быть инкапсулированы в этот класс и подчинены только этой задаче. Каждый программный модуль имеет ровно одну причину для изменения.

__Модуль должен отвечать за ровно одного актора.__

_Актор_ - группа лиц, желающих изменения. _Модуль_ - связанный набор функции и структур данных.  

### Признаки нарушения
* непреднамеренное дублирование
* слияния кода

# SOLID. Принцип открытости/закрытости
Open-closed principle: программные сущности должны быть открыты для расширения, но закрыты для модификации.

Цель принципа - сделать систему легко расширяемой и обезопасить ее от влияния изменений.

# SOLID. Принцип разделения интерфейсов
Interface segregation principle: много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс для общего назначение.

Следует избегать зависимости от всего, что не используется.

# SOLID. Принцип инверсии зависимости
Код, реализующий высокоуровневую политику, не должен зависеть от кода, реализующего низкоуровневые детали. Напротив, детали должны зависеть от политики.

Наиболее гибкими получаются системы, в которых зависимости в коде направлены на абстракции, а не на конкретные реализации.

Исходный код не должен зависеть от модулей с конкретной реализацией.

# REP: Reuse/Release Equivalence Principle
Единица повторного использования есть единица выпуска.

Классы и модули, составляющие компонент, должны принадлежать связной группе.
Компонент должен иметь общую тему или цель для всех классов и модулей.
Классы и модули, объединяемые в компонент должны выпускаться вместе.

# CCP: Common Closure Principle
В один компонент должны включаться классы, изменяющиеся по одним причинам и в одно время. В разные - наоборот.

_Это SRP для компонентов_

# CRP: Common Reuse Principle
Не вынуждайте пользователей компонента зависеть от того, что им не потребуется.

Классы, не имеющие тесной связи, не должны включаться в один компонент.

# Циклическая зависимость. Способы борьбы
* выделение интерфейса внутри одного модуля
* создание нового модуля с общей логикой

# Принцип устойчивых зависимостей. Метрики устойчивости
Зависимости должны быть направлены в сторону устойчивости.

#### Метрики устойчивости
```
неустойчивость = число входов / (число входов + число выходов)
```
Неустойчивость должна уменьшаться в направлении зависимости.

# Принцип устойчивости абстракций
Устойчивость компонента пропорциональна его абстракции.
Зависимость должна быть направлена в сторону абстракции.

# Архитектурные границы. Виды границ
Границы отделяют программные элементы друг от друга и избавляют их от небоходимости знать, что находится по ту сторону. 

* Компоненты развертывания
* Локальные процессы
* Службы
* Тесты

Уровень - удаленность от вводи и вывода.

# Шаблон «Скромный объект»
Разделить поведение на два модуля или класса: один "скромный" содержит все, что с трудом поддается тестированию в максимально упрощенном виде, второй - все, что выброшено из первого.

Разделяем на View (скромный) и Presenter (легко тестируемый).

# Лицензионные модели для открытого кода
* GNU (GPL) - если вы используете это ПО, должны тоже сделать его открытым
* GNU (LGPL) - можно использовать код в своих компонентах без необходимости публиковать исходный код
* BSD - можно включить код в продаваемые проприетарные  системы
* MIT - можно копировать, менять, сливать, публиковать код. Авторское право и условия должны быть включены во все копии или значимые части.

# Монолитное приложение. Проблемы монолитного приложения
* низкая производительность
* плохая масштабируемость
* долгие циклы регрессионного тестирования
* долгие циклы обновления и повторного развертывания
* незапланированные простои
* возможные простои на время обновления
* невозможность внедрения новых технологий
* невозможность выборочного масштабирования

# Микросервисы. Преимущества и недостатки. Переход к микросервисам
Преимущества:
* масштабируемость
* непрерывное развертывание
* больше свободы, меньше зависимости
* изоляция отказов
* разделение и децентрализация данных
* широта выбора инструментов

Недостатки:
* сложность поиска и устранения неисправностей
* увеличенные задержки
* сложность сопровождения
* управление версиями

# Брокер сообщений. Преимущества и недостатки
Промежуточное звено между сервисами.

Преимущества:
* слабая связность
* буферизация сообщений
* гибкое взаимодействие
* явное межпроцессное взаимодействие

Недостатки:
* потенциальное узкое место производительности и отказа
* дополнительная сложность в администрировании

# Способы устранения синхронного взаимодействия сервисов
* создание каналов для запросов и ответов
* репликация данных

# API-шлюз
Единая точка входа.

Преимущества:
* внутренняя сложность скрыта
* увеличение гибкости изменения, объединения, разделения или удаления микросервисов
* уменьшение трафика между клиентов и приложением

# Реестр служб
База данных микросервисов с их адресами. При запуске микросервис регистрирует себя в реестре. Когда клиент выполняет вызов, API-gateway определяет адреса необходимых микросервисов, вызывает их и объединяет полученные данные для передачи клиенту.

# REST и RESTful сервисы. HATEOAS
REpresentation State Transfer
* `GET` (создать)
* `POST` (прочитать)
* `PUT` (обновить)
* `DELETE` (удалить)

### Принципы RESTful
* использование HTTP-глаголов
* службы без сохранения состояния
* адресный URI, все ресурсы должны иметь URI с иерархической структурой
* использование XML или JSON (+ другие, например, аудио, видео)

### HATEOAS (hypermedia as the engine of application state)
Ресурсы сами описывают свои возможности и взаимосвязи. Гипертекст должен быть использован для навигации по API.

# Распределенные транзакции
* конечная согласованность
* распределенный менеджер транзакций
* журнал транзакций

X/Open XA - использует двухэтапную фиксацию. 

Чтобы зафиксировать распределенную транзакцию, все вовлеченные сервисы должны быть доступны.

# Шаблон «Повествование». Компенсирующие транзакции
Обеспечивает согласованность данных между сервисами, используя последовательность локализованных транзакций, которые координируются с помощью асинхронных сообщений.

* транзакции, доступные для компенсации
* поворотная транзакция, после нее повествование отработает до конца
* транзакции, доступные для повторения, всегда успешны

# Повествования на основе хореографии
Распределение принятия решений и упорядочивание действий между участниками повествования, которые в основном общаются, обмениваясь событиями.

* должны использовать тразакционный обмен сообщениями, обновление баз данных, публикация событий должны быть атомарными
* участники должны иметь возможность сопоставить каждое событие с собственными данными

#### Преимущества
* простота
* слабая связность

#### Недостатки
* сложнее для понимания
* циклические зависимости между сервисами
* риск жесткого связывания

# Повествования на основе оркестрации
Централизация координирующей логики повествования в виде класса-оркестратора. Оркестратор  отправляет участникам командные сообщения с инструкциями. 

#### Преимущества
* упрощенные зависимости, нет циклов
* меньше связывания, не нужно знать о других сервисах
* лучше разделение ответственности и упрощение логики

#### Недостатки
* риск избыточной централизации, лучше чтобы оркестратор не содержал бизнес-логики, а отвечал только за последовательное выполнение действий

# Тайм-ауты и автоматические выключатели в сервисах
Если второй сервис работает, оставляем несколько попыток на запрос и ограничиваем время на запрос. Если много раз получили timeout, считаем, что не работает

# Проектирование бизнес-логики в микросервисах. Доменная модель. Агрегат. Доменное событие
### Шаблон "Сценарий транзакции"
Бизнес-логика - набор процедурных сценариев транзакций, по одному для каждого типа запросов. Классы реализующие поведение отделены от классов, хранящих состояние.
### Шаблон "Доменная модель"
Бизнес-логика - классы с состоянием и поведением. Методы сервисов более простые, так как часть логики делегируется доменным объектам.
### Domain-Driven Desing (DDD)
Каждый сервис имеет собственную доменную модель, что позволяет избежать проблем с единой доменной моделью.

Блоки: Сущность, Объект значений, Фабрика, Репозиторий, Сервис
### Шаблон "Агрегат"
Агрегат - кластер доменных объектов, с которыми можно общаться как с единым целым.

1. ссылайтесь только на корень агрегата
2. Межагрегатные ссылки должны применять первичные ключи
3. Одна транзакция создает или обновляет один агрегат

# Порождение событий (event sourcing)
### Шаблон "Доменное событие"
Агрегат публикует доменное событие во время создания или изменения. Событие - представление изменения состояния.

### Шаблон "Порождение событий"
Сохраняет агрегат в виде последовательности доменных событий, которые представляют изменения состояния. Все изменения, вносимые в состояние приложения, сохраняются в последовательности выполнения.

Event sourcing способствует децентрализованному изменению и чтению данных.

Проблемы традиционного сохранения:
* классы привязаны к таблицам баз данных
* поля к столбцам
* экземпляры к строкам

События представляют изменение состояния.

Методы агрегата полностью полагаются на события.

Преимущества:
* надежная публикация
* сохранение истории изменений
* отсутствие проблем с объектно-реляционным разрывом

# Конкурентные обновления и оптимистичное блокирование
Каждый экземпляр агрегата содержит версию, которая считывается вместе с событиями. Когда приложение вставляет событие, хранилище проверяет, что его версия совпадает с версией события.

# Публикация событий с помощью опрашивания и с помощью отслеживания транзакционного журнала
### Публикация событий с помощью опрашивания
### Публикация событий с помощью отслеживания транзакционного журнала

# Хранилище событий
Гибрид базы данных и брокера сообщений:
* есть API для вставки и извлечения событий
* есть API для подписывания на события

Есть база данных событий, брокер сообщений для обработки событий.
# Шаблон «Объединение API»
# Шаблон CQRS. Причины использования
# Удушающее приложение и переход на микросервисную архитектуру. Стратегии перехода. Предохранительный слой
# Составной пользовательский интерфейс. Микроинтерфейсы

# Управление проектом. Критерий успеха. Универсальная управленческая деятельность
# Процесс управления рисками. Примеры различных типов рисков
# Планирование рисков. Примеры
# Мониторинг рисков. Индикаторы рисков
# Мотивация людей. Типы мотивации
# Модель DISC
# Ключевые области знаний и навыков тильда
