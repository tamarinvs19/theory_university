# Agile разработка. Agile манифест. Раздробленное видение <a name="1"></a>
* Это набор методов, который охватывает все области программирования (управление проектом, дизайн, архитектура, разработка)
* Все методы - четкие и оптимизированные процедуры
* Это мировоззрение

### Agile манифест
* Люди и взаимодействие важнее процессов и инструментов (ежедневные митинги, ретроспективы, user-story)
* Работающий программный продукт важнее исчерпывающей документации (разработка через тестирование)
* Сотрудничество с заказчиком важнее согласования условий контракта
* Готовность к изменениям важнее следования первоначальному плану (доска задач)

### Раздробленное видение
Чем больше люди сосредоточены на своих личных целях, а не на целях команды, тем меньше шансов, что они будут иметь реальную ценность для компании.
* Agile-митинги

# Agile-принципы <a name="2"></a>

1. Наш наивысший приоритет - это удовлетворение заказчика при помощи частых и непрерывных поставок ценного для него ПО. 
2. Мы принимаем изменения в требованиях даже на поздних этапах реализации для повышения конкурентоспособности продукта.
3. Мы стремимся поставлять полностью рабочее ПО каждые несколько недель. Чем чаще, тем лучше
4. Наиболее эффективный и действенный способ передачи информации - встреча членов команды разработки.
5. Представители бизнеса и команда разработчиков должны работать над проектом вместе.
6. Проекты строятся вокруг мотивированных людей.
7. Рабочее ПО - главная мера прогресса проекта.
8. Гибкие процессы способствуют непрерывному развитию. 
9. Постоянное внимание к техническому совершенству и качественной архитектуре способствует гибкости.
10. Простота - это искусство не делать лишений работы. KISS (Keep it simple, stupid)
11. Лучшая архитектура, требования и дизайн создаются в самоорганизующихся командах.
12. Команда постоянно ищет способы стать более эффективной путем настройки и коррекции своих действий.

# SCRUM. Схема scrum-проекта. Роли. Митинги <a name="3"></a>

### Роли
* Владелец продукта: определяет приоритеты функций, помогает команде понять ценность ПО, берет на себя выполнение обязательств, пишет user-story, создает планы релизов, проводит совместную ретроспективу
* Scrum-мастер: поддерживает правильное направление работы над проектом, помогает создать план, отслеживает прогресс, разбивает на итерации
* Член команды: выступает в роли владельца проекта, искренне считает, что их личный успех зависит от успешности проекта 

### Scrum-ценности
* Каждый человек ответственен за цели проекта
* Члены команды уважают друг друга
* Все сосредоточены на работе
* Команды ценят открытость
* Члены команды имеют мужество отстаивать проект

### Митинги
* обратная связь и цикл "обзор-контроль-адаптация" (что я сделал, что планирую, какие препятствия?)
* принятие решений в последний ответственный момент

# Спринты, планирование и ретроспективы. Фокус-фактор. Диаграммы сгорания работ <a name="4"></a>
* Инкрементальный процесс: сборка по частям
* Итеративный процесс: scrum-спринты

### Планирование
* user story -> story point
* задачи
* доска задач

Итог: цель, список участников + занятость, sprint backlog (список вошедших историй), дата демо

### Фокус-фактор
`FF = Actual Velocity / Available Man Days`

### Диаграммы сгорания работ
Способ показать и оценить прогресс

# XP. Практики программирования, интеграции, планирования. Командные практики <a name="5"></a>
### Практики программирования
* Разработка через тестирование
* Парное программирование
### Практики интеграции
* Десятиминутная сборка, авто-тесты, отчеты
* Непрерывная интеграция, система контроля версий
### Практики планирования
* Недельный цикл
* Квартальный цикл
* Временной запас
### Командные практики
* Коллокация
* Информативное рабочее пространство
* Излучатели информации
### Ценности
* Коммуникация
* Простота
* Обратная связь
* Мужество
* Уважение

# LEAN <a name="6"></a>
Бережливое мышление

### Ценности
* Ликвидируйте потери
* Усильте обучение, используйте обратную связь, чтобы улучшить работу
* Принимайте решения как можно позже
* Доставляйте ценность как можно раньше
* Раскрепостите вашу команду, объедините энергичных людей
* Добейтесь целостности, ПО должно работать сообразно ожиданиям
* Следите за общей картиной

# KANBAN. WIP <a name="7"></a>
KANBAN - способ улучшения процессов.

* Начните с того, что вы делаете сейчас, уважайте имеющиеся роли, обязанности и должностные конструкции
* Договоритесь об эволюционном развитии
* Поощряйте лидерство на всех уровнях

### Практики
* Визуализация
* Ограничение числа задач в работе (WIP)
* Управление потоком
* Сделайте правила явными
* Введите петли обратной связи
* Развивайтесь совместно и экспериментируйте

Канбан доски содержат только истории, могут устанавливаться лимиты, могут отличаться в разных командах

### WIP
Установление ограничения на количество рабочих элементов, которые могут находится на разных стадиях реализации проекта

# MSF. Модель процесса. <a name="8"></a>
Microsoft Solutions Framework

### Принципы
* Способствуйте открытому общению
* Работайте над общим видением
* Расширяйте полномочия членов команды
* Разделяйте ответственность
* Сотрудничайте с клиентом и сосредоточьтесь на предоставлении бизнес-ценности
* Будьте готовы к переменам и оставайтесь гибкими
* Инвестируйте в качество
* Учитесь на опыте

Модель команды - горизонтальная иерархия

Модель процесса - водопад + спиральная модель: выработка концепции -> концепция утверждена -> планирование -> планы утверждены -> разработка -> разработка завершена -> стабилизация -> версия готова -> внедрение -> внедрение завершено -> 

Управление проектом:
* комплексное планирование
* управление бюджетом, расходами и ресурсами
* подготовка графиков и контроль за их соблюдением
* ведение административной документации
 
Управление рисками: база рисков, определение, сообщение о, анализ и приоритет, план и график, отслеживание и отчет, контроль, знание

Управление готовностью: профессиональный рост, подготовка специалистов; от готовности зависит способность сотрудника выполнять ту или иную роль
- определение
- оценка
- изменение
- подведение итогов

# Программный процесс. Плановые и гибкие процессы. Виды деятельности <a name="9"></a>
Все программные процессы включают:
* спецификацию
* дизайн и внедрение
* валидацию
* эволюцию

__Модель программного процесса__ - _это абстрактное представление процесса. Представляет собой описание процесса с определенной точки зрения._

Описание ПП может включать:
- действия в процессах
- упорядочивание действий
- продукты (результат)
- роли (обязанности участников)
- пред-, постусловия

### Плановые и гибкие процессы
* в соответствии планом, прогресс относительно плана
* инкрементальное планирование, план может меняться

### Базис процессов разработки ПО:
* Деятельность
  * Действие
    * Задача

### Виды деятельности
* Подготовка (цели, сбор и анализ требований)
* Планирование (порядок работы, риск, ресурсы)
* Моделирование
* Конструирование
* Развертывание (поставка, внедрение, сопровождение)

### Виды защитной деятельности
* Отслеживание и контроль ПП
* Управление риском
* Обеспечение качества ПО
* Технические проверки
* Измерение
* Управление конфигурацией ПО
* Управление повторной используемостью
* Подготовка и производство рабочего продукта

# Модель и методология разработки ПО. Этапы жизненного цикла ПО <a name="10"></a>
Модель разработки ПО описывает, какие стадии жизненного цикла оно проходит и что происходит на каждой из них.

Методология - набор методов по управлению разработкой (правила, техники, принципы)

### Этапы жизненного цикла ПО
Жизненный цикл - этапы, через которые проходит ПО с начала создания до конца разработки
* Подготовка
* Проектирование
* Создание
  - Дизайн
  - Кодирование
  - Тестирование
  - Документирование
* Поддержка
 - Внедрение
 - Сопровождение

# Водопадная модель <a name="11"></a>
Waterfall Model / Каскадная модель
### Сопровождение ПО
* исправление ошибок 17%
* адаптация 18%
* усовершенствование по требованию заказчика 65%
### Достоинства
* разработку просто контролировать
* стоимость определяется на начальном этапе
* тестировщики могут опираться на техническую документацию
### Недостатки
* негибкое разделение на этапы -> сложно реагировать на меняющиеся требования
* тестирование на последних стадиях
* заказчик может дать обратную связь только на готовый продукт
* много документации, задержка, изменения при исправлении

# V-образная модель <a name="12"></a>
Параллельно проектированию происходит соответствующее тестирование

# Эволюционная модель <a name="13"></a>
Общая схема: получаем описание, создаем новые версии последовательно

* __Метод пробных разработок__ - заказчик не готов сразу определить полный состав требований
* __Метод прототипирования__ - заказчик готов определить полный набор требований, но разработчик не готов сразу предложить решения

### Достоинства
* сокращение сроков разработки
* возможность уточнять спецификацию компонентов
### Недостатки
* плохая документация
* плохая структура

# Спиральная модель <a name="14"></a>
Постепенная разработка с расширением функциональных возможностей.
### Достоинства
* объем работы при разработке одной версии меньше
* опыт разработки старших версий будет учтен
* в случае неудачи меньше материальные потери
* разработанные версии могут быть внедрены, реальная польза для заказчика
### Недостатки
* риск застрять на начальном этапе
* трудности контроля и управлением времени разработки
* повышенные требования к заказчику - нужно проверять версии

# Инкрементальная модель <a name="15"></a>
Последовательная реализация новой функциональности в новых версиях и развертывание каждой новой версии у заказчика.

### Достоинства
* на начальном этапе можно вкладывать меньше денег
* быстрый фидбэк от пользователей
* ошибка дешевле, чем в водопаде / V-образной модели

### Недостатки
* менеджер должен контролировать задачи разработчиков, чтобы развивалась требуемая функциональность
* могут быть проблемы с интерфейсов между командами

# Итеративная модель <a name="16"></a>
Модель, при которой заказчик не обязан понимать, какой продукт он хочет в итоге, может не прописывать подробное ТЗ. Один релиз.

### Достоинства
* быстрый выпуск минимального продукта -> быстрый фидбэк, можно фокусироваться на наиболее важных функциях и улучшать их по требованию
* постоянное тестирования пользователями

### Недостатки
* возможно потребуются сильные изменение в DB и сервере (масштабирование, нагрузка)
* нет фиксированного бюджета и сроков

# Ролевая модель команды. Менеджер проекта. Проектировщик. Разработчик. Тестировщик. <a name="17"></a>
### Менеджер проекта
* подбор и управление кадрами
* подготовка и исполнене плана продукта
* руководство командой
* обеспечение связи 
* обеспечение готовности продукта

### Проектировщик
* анализ требований
* разработка архитектуры и основных интерфейсов
* участие в планировании
* контроль выполнения
* участие в подборе кадров

### Разработчик
* создание кода
* контроль архитектурных и технических спецификаций
* подбор и конроль использования инструментов, стандартов
* диагностика и разрешение проблем
* контроль за работой тестировщиков
* мониторинг состояния

### Тестировщик
* составление плана тестирования
* контроль выполнения плана тестирования
* разработка тестов, автотестов
* выбор стандартов, метрик и инструментов

# Технический писатель. Технолог <a name="18"></a>
### Техписатель
* разработка плана документирования
* выбор и разработка стандартов и шаблонов подготовки документов
* выбор средств автоматизации документирования
* разработка документации
* организация тестирования документации
* участи в тестировании продукта

### Технолог
* поддрежка модели жизненного цикла
* создание и сопровождение среды сборки, процедуры установки версий
* управление исходниками

# Процессная деятельность. Спецификация, разработка, проверка и эволюция <a name="19"></a>
### Спецификация
* процесс определения того, какие услуги требуются, а также ограничений для работы и развития системы
* процесс разработки требований (сбор, детальное определение, проверка)

### Проверка
* верификация и валидация
* монитроринг
* системное тестирования: проверка на примерах

### Эволюция
* изменение требований из-за меняющихся обстоятельств

# Работа с меняющимися требованиями. Прототипирование. Инкрементальная доставка <a name="20"></a>
Преимущества прототипирования:
* повышение удобства системы
* более точное соответствие потребностям
* повышение качества дизайна
* повышение сопровождаемости
* снижение усилий при разработке

# Совершенствование процессов. Цикл улучшения процесса. <a name="21"></a>
* подход к зрелости процессов: улучшение уравления процессами и проектами и внедрении предовой практики разработки ПО; уровень зрелости - степень внедрения практик в процессы
* гибкий подход: итеративная разработка, сокращение накладных ресурсов; быстрое предоставление функциональности и реагирование на изменение требований 

Цикл: измерение -> анализ -> изменения

Измерение:
- количественные данные: время, ресурсы, количество появлений определенного события

# Capability Maturity Model (CMM) <a name="22"></a>
Уровни зрелости возможностей:
* Начальный: качество продукта определяется индивидуальными способностями разработчиков
* Повторяемый: есть записи о трудозатратах и планах, функциональность описана в письменной форме
* Установленный: имеют определенный, документированный процесс работы, не зависящий от отдельных личностей
* Управляемый: могут предсказать сроки и стоимость, есть база знаний
* Оптимизированный: постоянно действующая процедура поиска и освоения новых и улучшенных методов и инструментов

# Типы требований. Функциональные и нефункциональные требования <a name="23"></a>
* пользовательские требования: заявления на естественном языке + диаграммы сервисов, ограничения эксплуатации; для клиентов
* системные требования: документ с подробным описанием функций и ограничений, может быть частью контракта

### Функциональные требования
* описывают функциональные возможности системы
* зависят от типа ПО, пользователей, типа системы
* требования пользователей -> что система должна делать
* системные требования -> подробное описание услуги

### Нефункциональные требования
* свойства и ограничения системы: надежность, время отклика, требования к хранению... 
* могут быть к процессу, требующие IDE, язык или метод разработки
* могут быть более важными

### Полнота и последовательность требований
* полнота - должны включать описания всех необходимых объектов
* последовательность - нет противоречий

# Сбор и анализ требований. Интервью. Этнография. Истории и сценарии <a name="24"></a>
### Обнаружение требований
- сбор информации о требуемых и существующих системах, извлечение пользовательских и системных требований
- взаимодействие с заинтересованными сторонами системы
### Интервью / собеседование
* Типы:
  - закрытое по составленному списку вопросов
  - открытое с обсуждением различных вопросов с заинтересованными сторонами 
* Проблемы:
  - разный язык разных сфер
  - не подходит для понимания требований предметной области
### Этнография
* социолог тратит много времени на наблюдение и анализ того, как на самом деле работают люди
* не нужно объяснять или формулировать свою работу
* можно отметить важные социальные и организационные факторы
* работа обычно сложнее, чем предполагают простые модели
### Истории и сценарии
Примеры из реальной жизни, как можно использовать систему
* Сценарий - структурированная форма user story
 - исходная ситуация
 - нормальный поток событий
 - что может пойти не так
 - другая параллельная деятельность
 - состояние завершения

# Технические требования. Структурированные и табличные спецификации. Use cases <a name="25"></a>
* требования пользователей - понятны конечным пользователям и клиентам без техобразования
* системные требования - более подробная информация
### Способы написания спецификации системных требований
* естественный язык
* структурированный естественный язык
* язык описания дизайна
* графические обозначения
* математические характеристики

Структурированная спецификация - свобода составителя ограничена, требования написаны стандартным способом (список полей)
Табличная спецификация - для дополнения естественного языка

### Use cases
- варианты использования
- участники и все взаимодействия
- графическая модель высокого уровня дополнена табличным описанием
- диаграммы последовательности UML для добавления деталей

# Проверка/верификация требований. Методы проверки требований <a name="26"></a>
### Проверка
* достоверность
* последовательность
* полнота
* реалистичность
* проверяемость

### Методы проверки
* обзоры требований (ручной анализ)
* прототипирование
* генерация тест-кейсов (требования у проверке тестируемости)

### Верификация
* проверяемость
* понятность
* прослеживаемость
* адаптивность

# Управление требованиями и изменениями требований. <a name="27"></a>
__Управление требованиями__ - _процесс управления изменяющимися требованиями в процессе разработки требований и разработки системы_

* Идентификация требований
* Процесс управления изменениями: действия которые оценивают влияние и стоимость изменений
* Политики прслеживаемости: отношения между каждым требованием, между требованиями и проектом
* Инструменты для планирования

Изменение требований:
- анализ проблемы и изменение спецификации
- анализ изменений и вычисление стоимости изменений
- реализация изменения

# UML. Диаграммы классов. Атрибуты, ассоциации, кратность, зависимость. <a name="28"></a>
# Агрегация и композиция. Примеры. <a name="29"></a>
# Множественная классификация и множественное наследование. <a name="30"></a>
# UML. Диаграммы последовательности. Диаграммы прецедентов. <a name="31"></a>
# UML. Диаграммы состояний. Диаграммы деятельности <a name="32"></a>
# Модели взаимодействия. Примеры UML <a name="33"></a>
# Структурные модели. Примеры UML <a name="34"></a>
# Модели поведения. Примеры UML <a name="35"></a>
# Модельно-ориентированная инженерия <a name="36"></a>

# Дизайн и архитектура ПО. Две ценности программных систем. Достоинства хорошей архитектуры <a name="36"></a>
Архитектура - используется в контексте общих рассуждений.

Дизайн - подразумевает организацию и решения на более низком уровне.

Две ценности:
* Поведение (функциональность): срочное, но не всегда важное
* Структура (архитектура): важное, но не всегда срочное

Если программа работает правильно, но не допускает возможности изменения, когда изменятся требования, она перестанет работать правильно.

Если программа работает неправильно, но легко поддается изменению, ее можно заставить работать правильно.

__Архитектура программного проекта__ - _высокоуровневое представление структуры системы, спецификация ее компонентов и логики взаимодействия_

Хорошая архитектура должна обеспечивать:
* разнообразие вариантов использования и эффективную работу
* простота сопровождения
* простота разработки
* простота развертывания

# Многоуровневая архитектура <a name="37"></a>
Система - набор уровней (представление моделей, бизнес логика, хранение данных, базы данных)
- Используется при строительстве поверх существующих
- когда работа распределена между специализированными командами
- когда требуется многоуровневая безопасность
Преимущества:
- можно заменять слой отдельно, поддерживая интерфейс
- на каждом уровне можно предусматривать дополнительные средства (например, аутентификация)
Недостатки:
- четкое разделение сложно обеспечить
- производительность из-за нескольких уровней

# Модель - представление – контроллер. MVC, MVP, MVVM <a name="38"></a>
* Model - управляет системными данными
* View - определяет и управляет интерфейсом пользователя
* Controller - управляет взаимодействием с пользователем и передает его в представление и модель

```
С <-> V
|     ^
|     |
-> M <-
```

Цели:
- Добиться слабой связности между моделью и представлением, тогда можно сделать несколько представлений или легко изменить текущее
- Инкапсулировать бизнес-логику, чтобы разрабатывать и тестировать отдельно
- Сделать представление (view) максимально тонким, чтобы уменьшить тестирование

Преимущества:
- позволяет данным изменяться независимо от их представления и наоборот
- поддерживает одинаковое представление  различных данных

Недостатки: могут появиться дополнительные усложнения кода

MVC: контроллер - связь между пользователем и системой, отправляет данные между view и model; представление отвечает за получение данных из модели, предоставление их пользователю; модель предоставляет данные и методы работы с ними, ни от кого не зависит 

MVVM: модель - работа с данными; представление - графический интерфейс, подписчик на события изменения свойств или команд ViewModel, вызывает команды ViewModel при действиях пользователя; ViewModel - абстракция представления и обертка данных модели.

MVP: модели - данные; view - отображение данных из модели, обращается к presenter за обновлениями, перенаправляет события от пользователя в presenter; presenter - взаимодействие между model и view, содержит всю логику представления данных.


# Шаблон репозитория <a name="39"></a>
Все данные управляются в центральном репозитории, доступном для всех компонентов.

Использование:
- есть система, где генерирутся большие объемы информации, которую нужно хранить долго
- когда включение данных в репозиорий запускает действие

Преимущества:
- компоненты независимые, но имеют доступ к репозиторию
- изменения, внесенные одним компонентом могут быть распространены на все

Недостатки:
- репозиторий - единственная точка отказа системы
- возможна неэффективность в организации общения через репозиторий

# Архитектура каналов и фильтров <a name="40"></a>
Каждый компонент обработки (фильтр) - дискретный, выполняет один тип преобразования данных.

Использование: для поэтапной обработки данных

Преимущества:
- поддерживает повторное использование преобразований
- стиль соответствует структуре многих бизнес-проектов
- простое расширение функциональности
- может быть реализована как последовательная, так и параллельная

Недостатки:
- формат должен быть согласован, может увеличивать накладные расходы на проверку и преобразование данных

# Архитектура, управляемая событиями <a name="41"></a>
* распределенная и асинхронная
* высокая производительность, легкость развертывания, широкие возможности масштабирования

# Микроядерная архитектура <a name="42"></a>
Состоит из двух компонентов: основной системы (ядра) и плагинов.
Ядро - минимум бизнес-логики, управляет загрузкой, выгрузкой, запуском плагинов.
Плагины  не связаны между собой.

# Микросервисная архитектура <a name="43"></a>
Разделение функциональности на отдельные сервисы.

Преимущества:
-  высокая масштабируемость
- легкость распределения задач

Недостатки:
- необходимость передачи большого объема данных
- необходимость автоматизации развертывания и тестирования

# Модульная архитектура. Информационная закрытость <a name="44"></a>
- снижение сложности
- иерархическая декомпозиция
- обеспечиваем гибкость системы, масштабирование, устойчивость

### Информационная закрытость
- все модули независимы и обмениваются только той информацией, которая необходима для работы
- доступ к операциям и структурам данных модуля ограничен 
- позволяет обеспечить разработку модулей независимо
- позволяет обеспечить легкую модификацию

Идеальный модуль - черный ящик.

# Связность модуля. Типы связности <a name="45"></a>
### Модульная декомпозиция
- иерархическая декомпозиция (бизнес-логика, UI, DB, связь с оборудованием или ОС
- функциональная декомпозиция (один модуль - одна подзадача и один набор необходимых данных)

### High Cohesion + Low Coupling
- максимальная внутренняя связность (функциональная целостность, завершенность)
- минимальная внешняя связность (один вход и выход, логическая независимость, слабые связи с другими)

Внутренняя связность - мера зависимости частей модуля друг от друга
1. по совпадению 
1. логическая 
1. временнАя (нужны в один момент времени)
1. процедурная (независимые упорядоченные действия)
1. коммуникативная (используют одни данные или формируют общую структуру данных)
1. последовательная (конвейер для обработки данных)
1. функциональная (выполнение ровно одной проблемной задачи)

# Внешняя связанность / Coupling. Типы связности <a name="46"></a>
1. связность по данным
1. связность по образцу
1. связность по управлению
1. общая связность
1. связность по содержанию

# Парадигмы программирования
# ООП. Основные принципы
# SOLID. Принцип единственной ответственности
# SOLID. Принцип открытости/закрытости
# SOLID. Принцип разделения интерфейсов
# SOLID. Принцип инверсии зависимости
# REP: Reuse/Release Equivalence Principle
# CCP: Common Closure Principle
# CRP: Common Reuse Principle
# Циклическая зависимость. Способы борьбы
# Принцип устойчивых зависимостей. Метрики устойчивости
# Принцип устойчивости абстракций
# Архитектурные границы. Виды границ
# Шаблон «Скромный объект»
# Лицензионные модели для открытого кода
# Монолитное приложение. Проблемы монолитного приложения
# Микросервисы. Преимущества и недостатки. Переход к микросервисам
# Брокер сообщений. Преимущества и недостатки
# Способы устранения синхронного взаимодействия сервисов
# API-шлюз
# Реестр служб
# REST и RESTful сервисы. HATEOAS
# Распределенные транзакции
# Шаблон «Повествование». Компенсирующие транзакции
# Повествования на основе хореографии
# Повествования на основе оркестрации
# Тайм-ауты и автоматические выключатели в сервисах
# Проектирование бизнес-логики в микросервисах. Доменная модель. Агрегат. Доменное событие
# Порождение событий (event sourcing)
# Конкурентные обновления и оптимистичное блокирование
# Публикация событий с помощью опрашивания и с помощью отслеживания транзакционного журнала
# Хранилище событий
# Шаблон «Объединение API»
# Шаблон CQRS. Причины использования
# Удушающее приложение и переход на микросервисную архитектуру. Стратегии перехода. Предохранительный слой
# Составной пользовательский интерфейс. Микроинтерфейсы

# Управление проектом. Критерий успеха. Универсальная управленческая деятельность
# Процесс управления рисками. Примеры различных типов рисков
# Планирование рисков. Примеры
# Мониторинг рисков. Индикаторы рисков
# Мотивация людей. Типы мотивации
# Модель DISC
# Ключевые области знаний и навыков тильда
